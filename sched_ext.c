// This header is autogenerated, as explained later
#include <vmlinux.h>
// The following two headers come from the Linux headers library
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <string.h>

// Define a shared Dispatch Queue (DSQ) ID
// We use this as our global scheduling queue
#define SHARED_DSQ_ID 0

// Two macros that make the later code more readable
// and place the functions in the correct sections
// of the binary file
#define BPF_STRUCT_OPS(name, args...)	\
    SEC("struct_ops/"#name)	BPF_PROG(name, ##args)

#define BPF_STRUCT_OPS_SLEEPABLE(name, args...)	\
    SEC("struct_ops.s/"#name)							      \
    BPF_PROG(name, ##args)

// Initialize the scheduler by creating a shared dispatch queue (DSQ)
s32 BPF_STRUCT_OPS_SLEEPABLE(sched_init) {
    // All scx_ functions come from vmlinux.h
    return scx_bpf_create_dsq(SHARED_DSQ_ID, -1);
}

int BPF_STRUCT_OPS(sched_select_cpu, struct task_struct *p, s32 prev_cpu, u64 wake_flags)
{
	bool is_idle = false;
	s32 cpu;

	cpu = scx_bpf_select_cpu_dfl(p, prev_cpu, wake_flags, &is_idle);
	if (is_idle) {
		scx_bpf_dsq_insert(p, SCX_DSQ_LOCAL, SCX_SLICE_DFL, 0);
        bpf_printk("\t\tsched_select_cpu: selected idle CPU %d for task with PID %d", cpu, p->pid);
	}
    else
    {
        bpf_printk("\t\tsched_select_cpu: selected no CPU for task with PID %d", p->pid);
    }

	return cpu;
}

// Enqueue a task to the shared DSQ that wants to run, 
// dispatching it with a time slice
int BPF_STRUCT_OPS(sched_enqueue, struct task_struct *p, u64 enq_flags) {
    // Calculate the time slice for the task based on the number of tasks in the queue
    // This makes the system slightly more responsive than a basic round-robin
    // scheduler, which assigns every task the same time slice all the time
    // The base time slice is 5_000_000ns or 5ms
    //u64 slice = 5000000u / scx_bpf_dsq_nr_queued(SHARED_DSQ_ID);
    //scx_bpf_dispatch(p, SHARED_DSQ_ID, slice, enq_flags); 

    struct kernfs_node* node = NULL;
    //u64 cgroup_id = 0;

    struct cgroup* cgrp = scx_bpf_task_cgroup( p );

    const char *cg_name = cgrp ? cgrp->kn->name : NULL;

    int ret = -1;

    if ( cg_name )
    {
        char cg_name_buf[32];

        /* 2. Safely copy the string from the pointer into the buffer */
        //bpf_probe_read_str(cg_name_buf, sizeof(cg_name_buf), cg_name);
        // 1. Read the css_set pointer from the task_struct
        bpf_probe_read_kernel(&cg_name_buf, sizeof(cg_name_buf), cg_name);

        // 2. Read the cgroup ID from the css_set
        //bpf_probe_read_kernel(&cgroup_id, sizeof(cgroup_id), &cgroups->id);

        //if (strcmp(cg_name_buf, "hw") == 0) 
        {
            bpf_printk("\t\tsched_enqueue: accepted new task with PID %d on %s", p->pid, cg_name);

            scx_bpf_dsq_insert(p, SHARED_DSQ_ID, SCX_SLICE_DFL, enq_flags);

            ret = 0;
        }
    }

    bpf_cgroup_release(cgrp);

    return ret;
}

// Dispatch a task from the shared DSQ to a CPU,
// whenever a CPU needs something to run, usually after it is finished
// running the previous task for the allotted time slice
int BPF_STRUCT_OPS(sched_dispatch, s32 cpu, struct task_struct *prev) {
    scx_bpf_dsq_move_to_local(SHARED_DSQ_ID);

    bpf_printk("\t\tsched_dispatch: dispatched task with to CPU %d",  cpu);

    //scx_bpf_consume(SHARED_DSQ_ID);
    return 0;
}

int BPF_STRUCT_OPS(sched_enable, struct task_struct *p)
{
    return 0;
}

// Define the main scheduler operations structure (sched_ops)
SEC(".struct_ops.link")
struct sched_ext_ops sched_ops = {
    .enqueue        = (void *)sched_enqueue,
    .dispatch       = (void *)sched_dispatch,
    .init           = (void *)sched_init,
    .select_cpu	    = (void *)sched_select_cpu,
    .enable			= (void *)sched_enable,

    // There are more functions available, but we'll focus
    // on the important ones for a minimal scheduler
    //.flags     = SCX_OPS_ENQ_LAST | SCX_OPS_KEEP_BUILTIN_IDLE,
    .flags     = SCX_OPS_SWITCH_PARTIAL,
    // A name that will appear in
    // /sys/kernel/sched_ext/root/ops
    // after we attached the scheduler
    // The name has to be a valid C identifier
    .name      = "minimal_scheduler"
};

// All schedulers have to be GPLv2 licensed
char _license[] SEC("license") = "GPL";